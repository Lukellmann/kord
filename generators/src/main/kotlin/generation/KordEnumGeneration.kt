package dev.kord.generators.generation

import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.KModifier.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import dev.kord.generators.dsl.*
import dev.kord.generators.dsl.KordEnum.ValuesPropertyType
import dev.kord.generators.dsl.KordEnum.ValuesPropertyType.SET
import dev.kord.generators.dsl.KordEnum.Entry
import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializable
import kotlinx.serialization.descriptors.PrimitiveKind
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import kotlin.DeprecationLevel.*
import kotlin.LazyThreadSafetyMode.PUBLICATION
import com.squareup.kotlinpoet.INT as INT_CLASS_NAME
import com.squareup.kotlinpoet.SET as SET_CLASS_NAME
import com.squareup.kotlinpoet.STRING as STRING_CLASS_NAME

private val PRIMITIVE_SERIAL_DESCRIPTOR = MemberName("kotlinx.serialization.descriptors", "PrimitiveSerialDescriptor")
private val K_SERIALIZER = KSerializer::class.asClassName()

private val Entry<*>.warningSuppressedName
    get() = when (val deprecationLevel = deprecated?.level) {
        null -> name
        else -> "@Suppress(\"${
            when (deprecationLevel) {
                WARNING -> "DEPRECATION"
                ERROR, HIDDEN -> "DEPRECATION_ERROR"
            }
        }\")·$name"
    }

private fun KordEnum<*>.valueTypeClassNameForKordEnum() = when (this) {
    is IntKordEnum -> INT_CLASS_NAME
    is StringKordEnum -> STRING_CLASS_NAME
}

private fun KordEnum<*>.encodingPostfixForKordEnum() = when (this) {
    is IntKordEnum -> "Int"
    is StringKordEnum -> "String"
}

private fun KordEnum<*>.valueFormatForKordEnum() = when (this) {
    is IntKordEnum -> "%L"
    is StringKordEnum -> "%S"
}

private fun KordEnum<*>.primitiveKindForKordEnum() = when (this) {
    is IntKordEnum -> PrimitiveKind.INT::class
    is StringKordEnum -> PrimitiveKind.STRING::class
}

private fun ValuesPropertyType?.toClassName() = when (this) {
    null -> error("did not expect null") // todo
    SET -> SET_CLASS_NAME
}

private fun ValuesPropertyType?.toFromListConversion() = when (this) {
    null -> error("did not expect null") // todo
    SET -> ".toSet()"
}

internal fun <T : Comparable<T>> KordEnum<T>.generateFileSpec(packageName: String): FileSpec {

    val enumName = ClassName(packageName, name)
    val valueTypeName = valueTypeClassNameForKordEnum()
    val encodingPostfix = encodingPostfixForKordEnum()
    val valueFormat = valueFormatForKordEnum()

    val relevantEntriesForSerializerAndCompanion = entries
        .sortedBy { if (it.isDeprecated) 1 else 0 } // put deprecated behind non-deprecated
        .sortedBy { it.value } // sort is stable, deprecated entries stay behind non-deprecated with the same value
        .distinctBy { it.value } // entries with equal values will only have the first (non-deprecated) one selected

    // TODO remove eventually (always use "Serializer" then)
    val internalSerializerName = if (deprecatedSerializerName == "Serializer") "NewSerializer" else "Serializer"

    return FileSpec(packageName, fileName = name) {
        indent("    ")
        addFileComment("THIS FILE IS AUTO-GENERATED BY KordEnumProcessor.kt, DO NOT EDIT!")

        @OptIn(DelicateKotlinPoetApi::class) // `AnnotationSpec.get` is ok for `Suppress`
        addAnnotation(
            Suppress(
                "RedundantVisibilityModifier",
                "IncorrectFormatting",
                "ReplaceArrayOfWithLiteral",
                "SpellCheckingInspection",
                "GrazieInspection",
            )
        )

        addClass(enumName) {

            // KDoc for the kord enum
            run {
                val docLink = docUrl?.let { url -> "See [%T]s in the [Discord·Developer·Documentation]($url)." }
                val combinedKDocFormat = when {
                    kDoc != null && docLink != null -> "$kDoc\n\n$docLink"
                    else -> kDoc ?: docLink
                }
                combinedKDocFormat?.let { format -> addKdoc(format, enumName) }
            }

            addAnnotation<Serializable> {
                addMember("with·=·%T.$internalSerializerName::class", enumName)
            }
            addModifiers(PUBLIC, SEALED)
            primaryConstructor {
                addParameter(valueName, valueTypeName)
            }
            addProperty(valueName, valueTypeName, PUBLIC) {
                addKdoc("The raw $valueName used by Discord.")
                initializer(valueName)
            }

            addFunction("equals") {
                addModifiers(FINAL, OVERRIDE)
                returns<Boolean>()
                addParameter<Any?>("other")
                addStatement("return this·===·other || (other·is·%T·&&·this.$valueName·==·other.$valueName)", enumName)
            }

            addFunction("hashCode") {
                addModifiers(FINAL, OVERRIDE)
                returns<Int>()
                addStatement("return $valueName.hashCode()")
            }

            addFunction("toString") {
                addModifiers(FINAL, OVERRIDE)
                returns<String>()
                addStatement("return \"%T.\${this::class.simpleName}($valueName=\$$valueName)\"", enumName)
            }


            addClass("Unknown") {
                addKdoc(
                    "An unknown [%1T].\n\nThis is used as a fallback for [%1T]s that haven't been added to Kord yet.",
                    enumName,
                )
                addModifiers(PUBLIC)
                primaryConstructor {
                    addParameter(valueName, valueTypeName)
                }
                superclass(enumName)
                addSuperclassConstructorParameter(valueName)
            }


            for (entry in entries) {
                addObject(entry.name) {
                    entry.kDoc?.let { addKdoc(it) }
                    addModifiers(PUBLIC)
                    superclass(enumName)
                    addSuperclassConstructorParameter(valueFormat, entry.value)
                    entry.deprecated?.let {
                        @OptIn(DelicateKotlinPoetApi::class) // `AnnotationSpec.get` is ok for `Deprecated`
                        addAnnotation(it)
                    }
                }
            }


            addObject(internalSerializerName) {
                addModifiers(INTERNAL)
                addSuperinterface(K_SERIALIZER.parameterizedBy(enumName))

                addProperty<SerialDescriptor>("descriptor", OVERRIDE) {
                    initializer(
                        "%M(%S, %T)",
                        PRIMITIVE_SERIAL_DESCRIPTOR,
                        enumName.canonicalName,
                        primitiveKindForKordEnum()
                    )
                }

                addFunction("serialize") {
                    addModifiers(OVERRIDE)
                    addParameter<Encoder>("encoder")
                    addParameter("value", enumName)
                    addStatement("return encoder.encode$encodingPostfix(value.$valueName)")
                }

                addFunction("deserialize") {
                    addModifiers(OVERRIDE)
                    addParameter<Decoder>("decoder")
                    withControlFlow("return when·(val·$valueName·=·decoder.decode$encodingPostfix())") {
                        for (entry in relevantEntriesForSerializerAndCompanion) {
                            addStatement("$valueFormat·->·${entry.warningSuppressedName}", entry.value)
                        }
                        addStatement("else·->·Unknown($valueName)")
                    }
                }
            }


            // TODO bump deprecation level and remove eventually
            @OptIn(DelicateKotlinPoetApi::class)
            deprecatedSerializerName?.let { deprecatedSerializerName ->
                val name = this@generateFileSpec.name
                val deprecatedAnnotation = Deprecated(
                    "Use '$name.serializer()' instead.",
                    ReplaceWith("$name.serializer()", "$packageName.$name"),
                    level = ERROR,
                )
                val kSerializer = K_SERIALIZER.parameterizedBy(enumName)

                addObject(deprecatedSerializerName) {
                    addAnnotation(deprecatedAnnotation)
                    addModifiers(PUBLIC)
                    addSuperinterface(kSerializer, delegate = CodeBlock.of(internalSerializerName))

                    addFunction("serializer") {
                        addAnnotation(deprecatedAnnotation)
                        addModifiers(PUBLIC)
                        returns(kSerializer)
                        addStatement("return this")
                    }
                }
            }


            addCompanionObject {
                addModifiers(PUBLIC)

                addProperty("entries", LIST.parameterizedBy(enumName), PUBLIC) {
                    addKdoc("A [List] of all known [%T]s.", enumName)
                    delegate {
                        withControlFlow("lazy(mode·=·%M)", PUBLICATION.asMemberName()) {
                            addStatement("listOf(")
                            withIndent {
                                for (entry in relevantEntriesForSerializerAndCompanion) {
                                    addStatement("${entry.warningSuppressedName},")
                                }
                            }
                            addStatement(")")
                        }
                    }
                }

                // TODO bump deprecation level and remove eventually
                valuesPropertyName?.let { valuesPropertyName ->
                    addProperty(
                        valuesPropertyName,
                        valuesPropertyType.toClassName().parameterizedBy(enumName),
                        PUBLIC,
                    ) {
                        @OptIn(DelicateKotlinPoetApi::class) // `AnnotationSpec.get` is ok for `Deprecated`
                        addAnnotation(
                            Deprecated(
                                "Renamed to 'entries'.",
                                ReplaceWith("this.entries", imports = emptyArray()),
                                level = ERROR,
                            )
                        )
                        getter {
                            addStatement("return entries${valuesPropertyType.toFromListConversion()}")
                        }
                    }
                }

                // TODO remove eventually
                deprecatedSerializerName?.let { deprecatedSerializerName ->
                    val deprecatedSerializer = enumName.nestedClass(deprecatedSerializerName)

                    @OptIn(DelicateKotlinPoetApi::class)
                    addProperty(deprecatedSerializerName, deprecatedSerializer, PUBLIC) {
                        addAnnotation(Suppress("DEPRECATION_ERROR"))
                        addAnnotation(Deprecated("Binary compatibility", level = HIDDEN))
                        addAnnotation(JvmField())
                        initializer("%T", deprecatedSerializer)
                    }
                }
            }
        }
    }
}
